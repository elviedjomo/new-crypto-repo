# version: 0.2

# env:
#   variables:
#     AWS_DEFAULT_REGION: "us-east-1"
#     S3_BUCKET: "crypto-app-artifact-bucket"  # Your S3 Bucket Name
#     BUILD_FOLDER: "crypto-app-build"   # Folder inside S3 where `imageDetail.json` is stored

# phases:
#   pre_build:
#     commands:
#       - echo "Fetching imageDetail.json from S3 artifacts..."
#       - aws s3 cp s3://$S3_BUCKET/$BUILD_FOLDER/imageDetail.json .

#       - echo "Extracting IMAGE_URI from imageDetail.json..."
#       - IMAGE_URI=$(jq -r '.imageURI' imageDetail.json)
#       - |
#        echo "Using Image URI: $IMAGE_URI"

#       - echo "Logging into Amazon ECR..."
#       - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $(echo $IMAGE_URI | cut -d'/' -f1)
#       - echo "ECR login successful."

#   build:
#     commands:
#       - echo "Re-extracting IMAGE_URI..."
#       - IMAGE_URI=$(jq -r '.imageURI' imageDetail.json)  # Extract again

#       - echo "Pulling the Docker image from Amazon ECR..."
#       - docker pull $IMAGE_URI
#       - echo "Docker image pulled successfully."

#       # Start container and run tests
#       - echo "Running tests inside Docker container..."
#       - CONTAINER_ID=$(docker run -d -p 5000:5000 $IMAGE_URI)
#       - |
#        echo "Running container ID: $CONTAINER_ID"

#       # Wait for the service to start
#       - echo "Waiting for the container to be ready..."
#       - sleep 10  # Increased sleep time for stability

#       # Get Docker container IP address
#       - CONTAINER_IP=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' $CONTAINER_ID)
#       - |
#        echo "Container is running at: http://$CONTAINER_IP:5000"

#       # Run API health check
#       - echo "Checking service health..."
#       - curl -sSf http://$CONTAINER_IP:5000/ || (echo "Health check failed!" && exit 1)

#   post_build:
#     commands:
#       - echo "Stopping and removing container..."
#       - docker stop $CONTAINER_ID
#       - docker rm $CONTAINER_ID
#       - echo "Test job completed successfully."
version: 0.2

env:
  variables:
    AWS_DEFAULT_REGION: "us-east-1"
    # If your Pipeline's Test action is wired to take the Build output artifact,
    # imageDetail.json will already be in the working directory.
    # If you *must* fetch from S3, set these and flip USE_S3=true.
    S3_BUCKET: "crypto-app-artifact-bucket"
    BUILD_FOLDER: "crypto-app-build"
    USE_S3: "false"                 # prefer CodePipeline artifacts -> set to "true" only if needed
    EXTERNAL_PORT: "5000"           # host port
    CONTAINER_PORT: "5000"          # container port
    HEALTH_PATH: "/healthz"         # change if your app exposes a different probe path
    WAIT_TIMEOUT_SECONDS: "60"      # max wait for health to pass
    SLEEP_SECONDS: "2"              # polling interval

phases:
  pre_build:
    commands:
      - set -Eeuo pipefail
      - echo "==> Environment check"
      - docker --version
      - echo "Region: $AWS_DEFAULT_REGION"

      # 1) Obtain imageDetail.json (prefer artifact passed from Build stage)
      - |
        if [ "${USE_S3}" = "true" ]; then
          echo "==> Fetching imageDetail.json from s3://$S3_BUCKET/$BUILD_FOLDER/imageDetail.json"
          aws s3 cp "s3://$S3_BUCKET/$BUILD_FOLDER/imageDetail.json" .
        else
          echo "==> Using imageDetail.json from CodePipeline input artifact (recommended)"
        fi
      - test -f imageDetail.json || { echo "ERROR: imageDetail.json not found"; ls -la; exit 1; }

      # 2) jq (robust install for whichever base the CodeBuild image uses)
      - |
        if ! command -v jq >/dev/null 2>&1; then
          echo "==> Installing jq..."
          (command -v dnf && sudo dnf install -y jq) || \
          (command -v yum && sudo yum install -y jq) || \
          (command -v apt-get && sudo apt-get update && sudo apt-get install -y jq) || \
          { echo "ERROR: could not install jq"; exit 1; }
        fi

      # 3) Parse Image URI (accept various casings)
      - |
        IMAGE_URI=$(jq -r '.ImageURI // .imageURI // .imageUri // empty' imageDetail.json)
        test -n "$IMAGE_URI" && [ "$IMAGE_URI" != "null" ] || { echo "ERROR: ImageURI not found in imageDetail.json"; cat imageDetail.json; exit 1; }
        echo "==> Using Image URI: $IMAGE_URI"

      # 4) ECR login (derive registry host from IMAGE_URI)
      - REGISTRY_HOST="$(echo "$IMAGE_URI" | cut -d'/' -f1)"
      - echo "==> Logging in to ECR: $REGISTRY_HOST"
      - aws ecr get-login-password --region "$AWS_DEFAULT_REGION" | docker login --username AWS --password-stdin "$REGISTRY_HOST"

      # Precompute health URL
      - HEALTH_URL="http://127.0.0.1:${EXTERNAL_PORT}${HEALTH_PATH}"
      - echo "==> Health URL: $HEALTH_URL"

  build:
    commands:
      - echo "==> Pulling $IMAGE_URI"
      - docker pull "$IMAGE_URI"

      # Stable, unique container name
      - COMMIT_SHORT="$(echo "${CODEBUILD_RESOLVED_SOURCE_VERSION:-}" | cut -c1-7 || true)"
      - CONTAINER_NAME="ci-app-${CODEBUILD_BUILD_NUMBER:-0}-${COMMIT_SHORT:-na}"
      - echo "==> Container name: $CONTAINER_NAME"

      # Start container with its default CMD; pass PORT in case your image expects it
      - echo "==> Starting container and publishing $EXTERNAL_PORT:$CONTAINER_PORT"
      - docker run --name "$CONTAINER_NAME" -e PORT="$CONTAINER_PORT" -p "${EXTERNAL_PORT}:${CONTAINER_PORT}" -d "$IMAGE_URI"

      # Collect logs continuously in background for debugging if needed
      - echo "==> Tailing container logs to server.log"
      - (docker logs -f "$CONTAINER_NAME" > server.log 2>&1) &
      - LOG_PID=$!

      # Health wait loop: try host loopback first, then container IP as fallback
      - |
        echo "==> Waiting for service to become healthy..."
        deadline=$(( $(date +%s) + ${WAIT_TIMEOUT_SECONDS} ))
        READY=0
        while [ $(date +%s) -lt $deadline ]; do
          if curl -fsS "$HEALTH_URL" >/dev/null; then
            echo "==> Health check passed via host loopback: $HEALTH_URL"
            READY=1
            break
          fi
          sleep "${SLEEP_SECONDS}"
        done

        if [ "$READY" -ne 1 ]; then
          CIP="$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' "$CONTAINER_NAME" 2>/dev/null || true)"
          if [ -n "$CIP" ]; then
            ALT_URL="http://$CIP:${CONTAINER_PORT}${HEALTH_PATH}"
            echo "==> Trying container bridge IP: $ALT_URL"
            while [ $(date +%s) -lt $deadline ]; do
              if curl -fsS "$ALT_URL" >/dev/null; then
                echo "==> Health check passed via container IP: $ALT_URL"
                READY=1
                break
              fi
              sleep "${SLEEP_SECONDS}"
            done
          fi
        fi

        if [ "$READY" -ne 1 ]; then
          echo "ERROR: Health checks failed."
          echo "--- server.log (tail) ---"; tail -n 200 server.log || true
          echo "--- docker ps ---"; docker ps -a || true
          echo "--- ports ---"; docker inspect -f '{{json .NetworkSettings.Ports}}' "$CONTAINER_NAME" || true
          exit 1
        fi

  post_build:
    commands:
      - echo "==> Stopping container"
      - docker stop "$CONTAINER_NAME" >/dev/null 2>&1 || true
      - echo "==> Final server.log (tail)"
      - tail -n 120 server.log || true
      - echo "==> Tests completed successfully."

artifacts:
  files:
    - imageDetail.json
    - server.log
  discard-paths: yes

