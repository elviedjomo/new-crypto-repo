# version: 0.2

# env:
#   variables:
#     AWS_DEFAULT_REGION: "us-east-1"
#     S3_BUCKET: "crypto-app-artifact-bucket"  # Your S3 Bucket Name
#     BUILD_FOLDER: "crypto-app-build"   # Folder inside S3 where `imageDetail.json` is stored

# phases:
#   pre_build:
#     commands:
#       - echo "Fetching imageDetail.json from S3 artifacts..."
#       - aws s3 cp s3://$S3_BUCKET/$BUILD_FOLDER/imageDetail.json .

#       - echo "Extracting IMAGE_URI from imageDetail.json..."
#       - IMAGE_URI=$(jq -r '.imageURI' imageDetail.json)
#       - |
#        echo "Using Image URI: $IMAGE_URI"

#       - echo "Logging into Amazon ECR..."
#       - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $(echo $IMAGE_URI | cut -d'/' -f1)
#       - echo "ECR login successful."

#   build:
#     commands:
#       - echo "Re-extracting IMAGE_URI..."
#       - IMAGE_URI=$(jq -r '.imageURI' imageDetail.json)  # Extract again

#       - echo "Pulling the Docker image from Amazon ECR..."
#       - docker pull $IMAGE_URI
#       - echo "Docker image pulled successfully."

#       # Start container and run tests
#       - echo "Running tests inside Docker container..."
#       - CONTAINER_ID=$(docker run -d -p 5000:5000 $IMAGE_URI)
#       - |
#        echo "Running container ID: $CONTAINER_ID"

#       # Wait for the service to start
#       - echo "Waiting for the container to be ready..."
#       - sleep 10  # Increased sleep time for stability

#       # Get Docker container IP address
#       - CONTAINER_IP=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' $CONTAINER_ID)
#       - |
#        echo "Container is running at: http://$CONTAINER_IP:5000"

#       # Run API health check
#       - echo "Checking service health..."
#       - curl -sSf http://$CONTAINER_IP:5000/ || (echo "Health check failed!" && exit 1)

#   post_build:
#     commands:
#       - echo "Stopping and removing container..."
#       - docker stop $CONTAINER_ID
#       - docker rm $CONTAINER_ID
#       - echo "Test job completed successfully."
# version: 0.2

# env:
#   variables:
#     AWS_DEFAULT_REGION: "us-east-1"
#     S3_BUCKET: "crypto-app-artifact-bucket"
#     BUILD_FOLDER: "crypto-app-build"
#     EXTERNAL_PORT: "5000"      # host port
#     CONTAINER_PORT: "5000"     # container's listen port
#     HEALTH_PATH: "/"           # change to /health or /healthz if your app exposes one
#     FLASK_APP_NAME: "app:app"  # <<< set to your Flask app import path (e.g., wsgi:app, main:app, app.py)

# phases:
#   pre_build:
#     commands:
#       - 'set -euo pipefail'
#       - 'echo "Fetching imageDetail.json from s3://$S3_BUCKET/$BUILD_FOLDER/imageDetail.json ..."'
#       - 'aws s3 cp "s3://$S3_BUCKET/$BUILD_FOLDER/imageDetail.json" .'
#       - 'command -v jq >/dev/null || (echo "Installing jq..." && (yum install -y jq || (apt-get update && apt-get install -y jq)))'
#       - 'IMAGE_URI=$(jq -r ".imageUri // .imageURI // empty" imageDetail.json)'
#       - 'test -n "$IMAGE_URI" && [ "$IMAGE_URI" != "null" ] || { echo "ERROR: imageUri not found"; cat imageDetail.json; exit 1; }'
#       - 'echo "Using Image URI: $IMAGE_URI"'
#       - 'REGISTRY_HOST=$(echo "$IMAGE_URI" | cut -d"/" -f1)'
#       - 'aws ecr get-login-password --region "$AWS_DEFAULT_REGION" | docker login --username AWS --password-stdin "$REGISTRY_HOST"'
#       - 'HEALTH_URL="http://127.0.0.1:${EXTERNAL_PORT}${HEALTH_PATH}"'
#       - 'echo "Health URL (host loopback): $HEALTH_URL"'

#   build:
#     commands:
#       - 'echo "Pulling Docker image $IMAGE_URI"'
#       - 'docker pull "$IMAGE_URI"'

#       # Safe, stable container name
#       - 'COMMIT_SHORT=$(echo "${CODEBUILD_RESOLVED_SOURCE_VERSION:-}" | cut -c1-7 || true)'
#       - 'CONTAINER_NAME="ci-app-${CODEBUILD_BUILD_NUMBER:-0}-${COMMIT_SHORT:-na}"'
#       - 'echo "Container name: $CONTAINER_NAME"'

#       # Start Flask in foreground (no -d) and capture output to host log
#       - 'echo "Starting Flask: FLASK_APP=$FLASK_APP_NAME on 0.0.0.0:${CONTAINER_PORT} ..."'
#       - >
#         docker run --name "$CONTAINER_NAME"
#         -e FLASK_APP="$FLASK_APP_NAME"
#         -p "${EXTERNAL_PORT}:${CONTAINER_PORT}"
#         "$IMAGE_URI"
#         python -m flask run --host 0.0.0.0 --port "${CONTAINER_PORT}"
#         > server.log 2>&1 &
#       - 'sleep 1'
#       - 'echo "--- initial server.log (head) ---"; head -n 60 server.log || true'

#       # Health check: try host loopback first, then container bridge IP
#       - 'echo "Waiting for service to be ready..."'
#       - |
#         READY=0

#         # Try host loopback (published port)
#         for i in $(seq 1 20); do
#           if curl -fsS "$HEALTH_URL" >/dev/null; then
#             echo "Health check passed via host loopback: $HEALTH_URL"
#             READY=1
#             break
#           fi
#           sleep 2
#         done

#         # Fallback to container bridge IP if needed
#         if [ "$READY" -ne 1 ]; then
#           CIP="$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' "$CONTAINER_NAME" 2>/dev/null || true)"
#           if [ -n "$CIP" ]; then
#             ALT_URL="http://$CIP:${CONTAINER_PORT}${HEALTH_PATH}"
#             echo "Host loopback failed; trying container IP: $ALT_URL"
#             for i in $(seq 1 20); do
#               if curl -fsS "$ALT_URL" >/dev/null; then
#                 echo "Health check passed via container IP: $ALT_URL"
#                 READY=1
#                 break
#               fi
#               sleep 2
#             done
#           else
#             echo "Could not determine container IP."
#           fi
#         fi

#         # Final diagnostics on failure
#         if [ "$READY" -ne 1 ]; then
#           echo "Health checks failed. Diagnostics..."
#           echo "--- server.log (tail) ---"; tail -n 200 server.log || true
#           echo "--- docker ps ---"; docker ps -a || true
#           echo "--- container ports ---"; docker inspect -f '{{json .NetworkSettings.Ports}}' "$CONTAINER_NAME" || true
#           exit 1
#         fi

#   post_build:
#     commands:
#       - 'echo "Stopping container..."'
#       - 'docker stop "$CONTAINER_NAME" >/dev/null 2>&1 || true'
#       - 'echo "--- final server.log (tail) ---"'
#       - 'tail -n 80 server.log || true'
#       - 'echo "Test job completed successfully."'

# artifacts:
#   files:
#     - imageDetail.json
#     - server.log
#   discard-paths: yes
version: 0.2

env:
  variables:
    AWS_DEFAULT_REGION: "us-east-1"
    S3_BUCKET: "crypto-app-artifact-bucket"
    BUILD_FOLDER: "crypto-app-build"
    EXTERNAL_PORT: "5000"      # host port
    CONTAINER_PORT: "5000"     # container port
    HEALTH_PATH: "/healthz"    # change to "/" if you haven't added /healthz yet

phases:
  pre_build:
    commands:
      - 'set -euo pipefail'
      - 'echo "Fetching imageDetail.json from s3://$S3_BUCKET/$BUILD_FOLDER/imageDetail.json ..."'
      - 'aws s3 cp "s3://$S3_BUCKET/$BUILD_FOLDER/imageDetail.json" .'
      - 'command -v jq >/dev/null || (echo "Installing jq..." && (yum install -y jq || (apt-get update && apt-get install -y jq)))'
      - 'IMAGE_URI=$(jq -r ".imageUri // .imageURI // empty" imageDetail.json)'
      - 'test -n "$IMAGE_URI" && [ "$IMAGE_URI" != "null" ] || { echo "ERROR: imageUri not found"; cat imageDetail.json; exit 1; }'
      - 'echo "Using Image URI: $IMAGE_URI"'
      - 'REGISTRY_HOST=$(echo "$IMAGE_URI" | cut -d"/" -f1)'
      - 'aws ecr get-login-password --region "$AWS_DEFAULT_REGION" | docker login --username AWS --password-stdin "$REGISTRY_HOST"'
      - 'echo "ECR login succeeded."'

  build:
    commands:
      - 'echo "Pulling Docker image $IMAGE_URI"'
      - 'docker pull "$IMAGE_URI"'

      - 'COMMIT_SHORT=$(echo "${CODEBUILD_RESOLVED_SOURCE_VERSION:-}" | cut -c1-7 || true)'
      - 'CONTAINER_NAME="ci-app-${CODEBUILD_BUILD_NUMBER:-0}-${COMMIT_SHORT:-na}"'
      - 'echo "Container name: $CONTAINER_NAME"'

      # Start container with its own CMD; stream logs to server.log
      - 'echo "Starting container (-p ${EXTERNAL_PORT}:${CONTAINER_PORT}) ..."'
      - 'docker run -d --name "$CONTAINER_NAME" -p "${EXTERNAL_PORT}:${CONTAINER_PORT}" "$IMAGE_URI"'
      - 'sleep 1'
      - 'docker logs -f "$CONTAINER_NAME" > server.log 2>&1 & LOG_PID=$!'
      - 'trap "docker rm -f $CONTAINER_NAME >/dev/null 2>&1 || true; kill $LOG_PID >/dev/null 2>&1 || true" EXIT'
      - 'echo "--- initial server.log (head) ---"; head -n 60 server.log || true'

      # Health check: container IP first (fast), then host loopback as fallback
      - |
        echo "Waiting for service to be ready (container IP, then host loopback) ..."
        READY=0

        CIP="$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' "$CONTAINER_NAME" 2>/dev/null || true)"
        if [ -n "$CIP" ]; then
          ALT_URL="http://$CIP:${CONTAINER_PORT}${HEALTH_PATH}"
          echo "Trying container IP: $ALT_URL"
          for i in $(seq 1 20); do
            if curl -fsS "$ALT_URL" >/dev/null; then
              echo "Health check passed via container IP: $ALT_URL"
              READY=1
              break
            fi
            sleep 2
          done
        else
          echo "Could not determine container IP."
        fi

        if [ "$READY" -ne 1 ]; then
          HEALTH_URL="http://127.0.0.1:${EXTERNAL_PORT}${HEALTH_PATH}"
          echo "Trying host loopback: $HEALTH_URL"
          for i in $(seq 1 10); do
            if curl -fsS "$HEALTH_URL" >/dev/null; then
              echo "Health check passed via host loopback: $HEALTH_URL"
              READY=1
              break
            fi
            sleep 2
          done
        fi

        if [ "$READY" -ne 1 ]; then
          echo "Health checks failed. Diagnostics..."
          echo "--- server.log (tail) ---"; tail -n 200 server.log || true
          echo "--- docker ps ---"; docker ps -a || true
          echo "--- container ports ---"; docker inspect -f '{{json .NetworkSettings.Ports}}' "$CONTAINER_NAME" || true
          exit 1
        fi

  post_build:
    commands:
      - 'echo "Stopping container..."'
      - 'docker stop "$CONTAINER_NAME" >/dev/null 2>&1 || true'
      - 'if [ -n "${LOG_PID:-}" ]; then kill "$LOG_PID" >/dev/null 2>&1 || true; fi'
      - 'sleep 1'
      - 'echo "--- final server.log (tail) ---"'
      - 'tail -n 120 server.log || true'
      - 'echo "Test job completed successfully."'

artifacts:
  files:
    - imageDetail.json
    - server.log
  discard-paths: yes
